/**
 * This file is part of Jumbo framework for Node.js
 * Written by Roman Jámbor ©
 */

"use strict";

// Will be initiated when required
var $fs, $path, fileExtensionToMimeMap;

// Cross request storage
var crossRequestDataStorage = {};

/**
 * Locator instance
 * @type {Locator}
 */
const locator = Jumbo.Application.Locator.instance;

/**
 * Object mapping x-jumbo-request types to controler actions
 */
const xjumboRequestActionMap = {
	"contentView": function(ctrl, viewOrData, data = null) {
		ctrl.singleView(viewOrData, data);
	},
	"template": function(ctrl, viewOrData) {
		ctrl.template(typeof view == "string" ? view : null);
	},
	"viewData": function(ctrl, viewOrData, data = null) {
		ctrl.returnJson(data || viewOrData || {});
	},
};

/**
 * Name of HTTP header property which should tellwhich view type is required
 * @type {string}
 */
const xJumboViewTypeHeaderPropName = "x-jumbo-requested-view";
const X_JUMBO_VIEW_TYPE_HEADER_PROP_NAME = "x-jumbo-requested-view";

/**
 * Core controller of framework
 * @memberOf Jumbo.Base
 */
class Controller {

	protected get url() {
		return new Url(this.request);
	}

	//<editor-fold desc="Ctor">

	/**
	 * @constructor
	 */
	constructor() {
		/**
		 * Incoming request
		 * @type {Jumbo.Application.Request}
		 */
		this.request = null;

		/**
		 * Session object, you can use it for whatever you want.
		 * All data stored here are specific for one client and all data are accessible through all client's request
		 * @type {Object}
		 */
		this.session = {};

		/**
		 * Controller scope of DI
		 * @type {Jumbo.Ioc.Scope}
		 */
		this.scope = null;

		/**
		 * @private
		 * @type {boolean}
		 */
		this.exited = false;

		/**
		 * Callback function
		 * @type {Function}
		 * @protected
		 */
		this.callback = (() => {
			Jumbo.Logging.Log.error("Controller's callback wasn't set");
			this.request.response.writeHead(500, {"Content-Type": "text/plain"});
			this.request.response.end("Status code 500\nWe are sorry, but some error (#001) occurs.");
		});

		/**
		 * Data stored to next request
		 * @type {Proxy}
		 */
		this.crossRequestData = null;
	}

	//</editor-fold>

	//<editor-fold desc="Private Methods">

	/**
	 * @private
	 * @ignore
	 * @param {Jumbo.Application.Request} request
	 * @param {Object} session
	 * @param {Function} callback
	 * @param {Jumbo.Ioc.Scope} scope
	 */
	initController(request, session, callback, scope) {
		this.session = session;
		this.request = request;
		this.callback = callback;
		this.scope = scope;

		/**
		 * Data stored to next request
		 * @type {Proxy}
		 */
		this.crossRequestData = new Proxy({}, {
			get: function (obj, key) {
				if (!crossRequestDataStorage.hasOwnProperty(request.sessionId)) {
					return;
				}

				return crossRequestDataStorage[request.sessionId][key];
			},
			set: function (obj, key, value) {
				if (!crossRequestDataStorage.hasOwnProperty(request.sessionId)) {
					crossRequestDataStorage[request.sessionId] = {};
				}

				return crossRequestDataStorage[request.sessionId][key] = value;
			},
			getOwnPropertyDescriptor: function (obj, key) {
				if (!crossRequestDataStorage.hasOwnProperty(request.sessionId)) {
					return undefined;
				}

				return Object.getOwnPropertyDescriptor(crossRequestDataStorage[request.sessionId], key);
			}
		});
	}

	/**
	 * Clear all old cross request data which already lived cross two requests
	 */
	clearOldCrossRequestData() {
		if (!crossRequestDataStorage.hasOwnProperty(this.request.sessionId)) {
			return;
		}

		delete crossRequestDataStorage[this.request.sessionId];
	}

	//</editor-fold>

	//<editor-fold desc="Public Methods">

	/**
	 * Check if current request is XHR request.
	 * Checking x-requested-with for being "XMLHttpRequest" in request header
	 * @obsolete
	 * @returns {boolean}
	 */
	isXhr() {
		return this.request.request.headers['x-requested-with'] && this.request.request.headers['x-requested-with'].toLowerCase() == "xmlhttprequest";
	}

	//noinspection JSMethodCanBeStatic
	/**
	 * Generates URL for given Controller and Action
	 * @param {String} controller Controller name
	 * @param {String} action Action name
	 * @param {Array} [slashParams] Array of slash parameters
	 * @param {Object} [queryParams] List of named parameters
	 * @param {String} lang
	 * @returns {string}
	 */
	link(controller, action, slashParams, queryParams, lang) {
		return locator.generateUrl(controller, action, slashParams, queryParams, null, lang);
	}

	//noinspection JSMethodCanBeStatic
	/**
	 * Generate URL for given Controller and Action
	 * @param {String} subApp Name of sub application
	 * @param {String} controller Controller name
	 * @param {String} action Action name
	 * @param {Array} [slashParams] Array of slash parameters
	 * @param {Object} [queryParams] List of named parameters
	 * @param {String} lang
	 * @returns {string}
	 */
	appLink(subApp, controller, action, slashParams, queryParams, lang) {
		return locator.generateUrl(controller, action, slashParams, queryParams, subApp, lang);
	}

	//noinspection JSMethodCanBeStatic
	/**
	 * Generates URL for given Location
	 * @param {String} locationName Name of Location
	 * @param {String} controller Controller name
	 * @param {String} action Action name
	 * @param {Object} [params] Object with names parameters
	 * @returns {String}
	 */
	locationLink(locationName, controller, action, params) {
		return locator.generateLocationUrl(locationName, controller, action, params);
	}

	/**
	 * Completly ends basic workflow. Call it if you processed request/response on your own.
	 */
	exit() {
		this.exited = true;
		this.callback(null, {wasReturned: true});
		this.callback = function () {
		};
	}

	/**
	 * Add message to data for view, allow rendering messaes for clients.
	 * Messages are hold in cookie for next request or to time of first reading.
	 * @param {String} message
	 * @param {String} [messageType]
	 */
	addMessage(message, messageType) {
		if (!crossRequestDataStorage.hasOwnProperty(this.request.sessionId)
			|| !crossRequestDataStorage[this.request.sessionId].hasOwnProperty(Controller.clientMessagesId)) {
			this.crossRequestData[Controller.clientMessagesId] = [];
		}

		crossRequestDataStorage[this.request.sessionId][Controller.clientMessagesId]
		.push({message: message, type: messageType});
	}

	/**
	 * Ends request and return default or given view with given data
	 * @param {String | Object} [viewOrData] Name of specific view or just data
	 * if your wanted view is default (if match with action name)
	 * @param {Object} [data] Data object
	 */
	renderView(viewOrData, data = null) {
		var rtrnData = {};

		if (typeof viewOrData == "string") {
			rtrnData.view = viewOrData;
			rtrnData.data = data || {};
		} else {
			rtrnData.view = null;
			rtrnData.data = viewOrData || {};
		}

		this.exited = true;
		this.callback(null, rtrnData);
		this.callback = function () {
		};
	}

	/**
	 * Ends request and return default or given view with given data but without layout
	 * @param {String | Object} [viewOrData] Name of specific view or just data
	 * if your wanted view is default (if match with action name)
	 * @param {Object} [dataOrSnippetName] Data object or snppet name if first param contains data
	 * @param {string} [snippetName] Name of BLOCK which will be returned to client
	 */
	snippetView(viewOrData, dataOrSnippetName = null, snippetName = "content") {
		var rtrnData = {
			snippetName: snippetName,
			isSingle: true,
			isSnippet: true
		};

		if (typeof viewOrData == "string") {
			rtrnData.view = viewOrData;
			rtrnData.data = data || {};
		} else {
			rtrnData.view = null;
			rtrnData.data = viewOrData || {};
			rtrnData.snippetName = dataOrSnippetName || snippetName;
		}

		this.exited = true;
		this.callback(null, rtrnData);
		this.callback = function () { };
	}

	/**
	 * Ends request and return single view without layout.
	 * Template mush have own output, no block is used from ouside template.
	 * @param {String} [singleView] Name of specific view
	 * @param {Object} [data] Data object
	 */
	singleView(singleViewOrData = null, data = null) {
		var rtrnData = {
			isSingle: true
		};

		if (typeof viewOrData == "string") {
			rtrnData.view = singleViewOrData;
			rtrnData.data = data || {};
		} else {
			rtrnData.view = null;
			rtrnData.data = singleViewOrData || {};
		}

		this.exited = true;
		this.callback(null, rtrnData);
		this.callback = function () {};
	}

	/**
	 * Return raw template without rendering
	 * @param view
	 */
	template(view = null) {
		this.exited = true;
		this.callback(null, {
			view: view,
			isRaw: true,
			data: {}
		});
		this.callback = function () {
		};
	}

	/**
	 * Return view or specific required type if request is XHR with special header.
	 * It return full rendered view, rendered content view, raw template or just JSON data for given template.
	 * @param {String | Object} viewOrData
	 * @param {Object} [data]
	 */
	view(viewOrData, data = null) {
		if (this.isXhr()) {
			var action = xjumboRequestActionMap[this.request.request.headers[X_JUMBO_VIEW_TYPE_HEADER_PROP_NAME]];

			if (!action) {
				this.renderView(viewOrData, data);
			}

			action(this, viewOrData, data)
			return;
		}

		this.renderView(viewOrData, data);
	}

	/**
	 * Ends request with empty result
	 */
	returnEmpty() {
		this.exited = true;
		this.request.header["Content-Length"] = 0;
		this.request.response.writeHead(200, this.request.header);
		this.request.response.end();
		this.callback(null, {wasReturned: true});
		this.callback = function () {
		};
	}

	/**
	 * Ends request with result of given data and type
	 * @param data
	 * @param {String} [type] Content-type
	 */
	returnData(data, type = "text/plain") {
		this.exited = true;
		if (type && type.trim().length != 0) {
			this.request.header['Content-Type'] = type;
		}

		this.request.header["Content-Length"] = Buffer.byteLength(data, "utf-8");

		this.request.response.writeHead(200, this.request.header);
		this.request.response.end(data);
		this.callback(null, {wasReturned: true});
		this.callback = function () {
		};
	}

	/**
	 * Ends request with JSON result
	 * @param {Object} jsonObj
	 */
	returnJson(jsonObj) {
		this.exited = true;
		this.returnData(JSON.stringify(jsonObj), "application/json");
	}

	/**
	 * Ends request with error result. HTML file in /data/errors with given statusCode will be sent to client.
	 * If file not exists, plain text message "We're sorry but some error occurs." will be shown.
	 * @param {String} message Message which will be logged, it doesn't display to client
	 * @param [statusCode] default 500
	 */
	returnError(message, statusCode = 500) {
		this.exited = true;
		this.callback({
			status: statusCode,
			message: message
		});
		this.callback = function () {
		};
	}

	/**
	 * Sends file to client for download
	 * @param {String} filePath
	 * @param {String} [newName]
	 */
	returnFileDownload(filePath, newName, contentType) {
		// Require fs if it hasn't been required yet
		if (!$fs) {
			$fs = require("fs");
		}

		// Require path if it hasn't been required yet
		if (!$path) {
			$path = require("path");
		}

		if (!contentType && !fileExtensionToMimeMap) {
			fileExtensionToMimeMap = require("../utils/file-extension-to-mime-map");
		}

		$fs.lstat(filePath, (error, stats) => {
			if (error || !stats || !stats.isFile()) {
				this.returnError("File '" + filePath + "' given for download is not valid file.", 404);
				return;
			}

			if (!newName) {
				newName = $path.parse(filePath).base;
			}

			var mime = contentType || fileExtensionToMimeMap[$path.extname(filePath).slice(1)];

			this.request.response.writeHead(200, {
				"Content-Disposition": "attachment; filename=" + newName,
				"Content-Type": mime,
				"Content-Length": stats.size
			});

			$fs.createReadStream(filePath).pipe(this.request.response);

			this.exit();
		});
	}

	//</editor-fold>
}

Controller.clientMessagesId = "_clientMessages";

module.exports = Controller;