/**
 * This file is part of Jumbo framework for Node.js
 * Written by Roman JÃ¡mbor
 */

"use strict";

//<editor-fold desc="Requires">

const $fs = require("fs");
const $path = require("path");
const $cluster = require("cluster");
const $less = require("less");
const $formidable = require("formidable");

const $clusterCmds = require("../cluster/cluster-messaging");
const fileExtensionToMimeMap = require("../utils/file-extension-to-mime-map");
const Jumplate = require("jumbo-template");
const $cfg = require("../config");

var $https = null;
var $http = null;
if (Jumbo.Config.protocol.protocol == $cfg.Protocols.Https) {
	$https = require("https");
} else {
	$http = require("http");
}

//</editor-fold>

//<editor-fold desc="Declares">

// Shorcuts
const clientMessageId = Jumbo.Base.Controller.clientMessagesId;
const Log = Jumbo.Logging.Log;
const debugMode = Jumbo.Config.debugMode;

// Number of seconds, time for collecting data, after that time are limits (amplified by this number) checked
const checkIntervalTime = 5;

const tplCacheExtension = ".tplcache";

// Initiated from runWhenReady - after application ready
var defaultActionRegExp;

//</editor-fold>

/**
 * Class which contain HTTP server and do all the basic job around requests.
 * It cares about static files, POST data, routing, creation of controllers and calling actions
 * @memberOf Jumbo.Application
 */
class Application {

	//<editor-fold desc="Virtual Definitions">

	/**
	 * Virtual callback for staticFileResolver handler function
	 * @callback staticFileResolverCallback
	 * @paam {Error} error
	 * @param {Stream} fileStream
	 * @param {String} mime MIME file type
	 * @param {Number} size Size of file
	 */

	/**
	 * Virtual function describing interface of staticFileResolverCallback handler
	 * @callback staticFileResolverHandler
	 * @param {String} fileName
	 * @param {staticFileResolverCallback} callback
	 */

	/**
	 * @callback banIpListener
	 * @param {String} ip
	 */

	/**
	 * @typedef {{render: function, preCompile: function, renderPreCompiled: function, extension: string, preCompilation: boolean}} TemplateAdapter
	 */

	//</editor-fold>

	//<editor-fold desc="Static Properties">

	/**
	 * Default controller name
	 * @type {string}
	 */
	static get defaultController() {
		return "Home";
	}

	/**
	 * Default action name
	 * @type {string}
	 */
	static get defaultAction() {
		return "index"
	}

	//</editor-fold>

	//<editor-fold desc="Ctor">

	/**
	 * Constructs Application
	 */
	constructor() {
		/**
		 * HTTP server
		 * @private
		 */
		this.server = null;

		/**
		 * Will be true after completing all startup tasks.
		 * This fields is checked by interval in runWhenReady
		 * @private
		 * @type {boolean}
		 */
		this.serverIsReady = false;

		/**
		 * Will be true after setting up http server
		 * @type {boolean}
		 */
		this.serverIsRunning = false;

		/**
		 * HTTP server port
		 * @private
		 * @type {number}
		 */
		this.port = 80;

		/**
		 * Request statistics (for blocking and banning)
		 * @private
		 * @type {{}}
		 */
		this.requests = { // Loaded from config, these values are default
			limit: 0, // 0  disabled
			totalCount: 0,
			checkInterval: null,

			limitIP: 0,
			banTime: 3600,
			countPerIP: {
				/*
				 "xxx.xxx.xxx.xxx": Number // Number of request in last second from given IP
				 */
			},
			blockedIPs: {
				/*
				 "xxx.xxx.xxx.xxx": Time() // Ban end time
				 */
			}
		};

		/**
		 * Locator for adress verifying and resolving
		 * @private
		 * @type {Jumbo.Application.Locator}
		 */
		this.locator = Jumbo.Application.Locator.instance;

		/**
		 * DIContainer for resolving rependencies
		 * @private
		 * @type {Jumbo.Ioc.DIContainer}
		 */
		this.diContainer = Jumbo.Ioc.DIContainer.instance;

		/**
		 * Controller factory
		 * @private
		 * @type {Jumbo.Application.ControllerFactory}
		 */
		this.controllerFactory = Jumbo.Application.ControllerFactory.instance;

		/**
		 * Memory sessions
		 * @private
		 * @type {{}}
		 */
		this.sessions = {};

		/**
		 * Current size of saved session data
		 * // TODO: Implement
		 * @private
		 * @type {number}
		 */
		this.sessionsSize = 0;

		/**
		 * Memory cache for compiled templates
		 * @private
		 * @type {{}}
		 */
		this.memoryCache = {};

		/**
		 * Array creating FIFO queue which will hold memoryCache IDs in order as added
		 * If memoryCacheSize will be reached, first added ID will be removed
		 * @type {Array}
		 */
		this.memoryCacheQueue = [];

		/**
		 * Current size of cached templates
		 * @private
		 * @type {number}
		 */
		this.memoryCacheSize = 0;

		/**
		 * Handler which should return file for given URL
		 * @private
		 * @type {staticFileResolverHandler}
		 */
		this.staticFileResolver = (fileName, callback) => {
			$fs.lstat(fileName, (error, stats) => {
				if (error) {
					callback(error, null);
					return;
				}

				if (stats.isFile()) {
					var mime = fileExtensionToMimeMap[$path.extname(fileName).slice(1)];
					callback(null, $fs.createReadStream(fileName), mime, stats.size);
				} else if (stats.isDirectory()) {
					callback(new Error("Accessing folder content is not allowed."));
				} else {
					callback(new Error("File not found."));
				}
			});
		};

		/**
		 * Listener which will be called when after IP block
		 * @private
		 * @type {null}
		 */
		this.blockIpListener = null;

		/**
		 * Template adapter
		 * @type {TemplateAdapter}
		 */
		this.templateAdapter = null;


		// Array for actions creating sequence
		var startActionSequence = [
			(done) => {
				// Create HTTP server
				this.createServer();

				done();
			},
			() => {
				this.serverIsReady = true;
				this.initClustering();
			}
		];

		// Only for main process
		if ($cluster.isMaster) {
			// Remove createServer from sequence
			if (!debugMode) {
				startActionSequence.shift();
			}

			// Compile less
			startActionSequence.unshift((done) => {
				this.compileLESS(() => {
					done();
				});
			});
		}

		new Jumbo.Sync.Sync(startActionSequence);
	}

	//</editor-fold>

	//<editor-fold desc="Public Methods">

	/**
	 * Return Locator instance
	 * @returns {Jumbo.Application.Locator}
	 */
	getLocator() {
		return this.locator;
	}

	/**
	 * Return DI Container
	 * @returns {Jumbo.Ioc.DIContainer}
	 */
	getDIContainer() {
		return this.diContainer;
	}

	/**
	 * Set handler for resolving static files
	 * @param {Function} handler
	 */
	setStaticFileResolver(handler) {
		this.staticFileResolver = handler;
	}

	/**
	 * You can obtain blocked IPs through your listener registered here
	 * @param {banIpListener} listener
	 */
	setBlockIpListener(listener) {
		if (typeof listener != "function") {
			throw new Error("Listener must be function!");
		}

		this.blockIpListener = listener;
	}

	/**
	 * Set your template adapter
	 * @param {TemplateAdapter} adapter
	 */
	setTemplateAdapter(adapter) {
		if (adapter.constructor != Object || !adapter.hasOwnProperty("extension")
			|| !adapter.hasOwnProperty("preCompilation")
		) {
			console.error("Adapter you are trying to register in not Object!");
			this.exit();
		}

		this.templateAdapter = adapter;
	}

	/**
	 * Register function which will be executed in interval of given length
	 * @param {Number} time Number of seconds
	 * @param {Function} func Your function
	 */
	registerIntervalTask(time, func) {
		if ($cluster.isMaster) {
			setInterval(func, time * 1000);
		}
	}

	/**
	 * Register function which will be executed once per day in given time
	 * @param {Number} hour Hour when you want to run your function
	 * @param {Number} minute Minute in hour when you want to run your function
	 * @param {Number} second Second in minute
	 * @param {Function} func Your function
	 */
	registerDailyTask(hour, minute, second, func) {
		throw new Error("Not implemented yet!");

		// if ($cluster.isMaster) {
		// 	var now = new Date();
		// 	var hDiff = hour - now.getHours();
		// 	var mDiff = minute - now.getMinutes();
		// 	var sDiff = second - now.getSeconds();
		// 	var timeToRun = 0;
		//
		// TODO: Implement
		// 	if (hDiff < 0 && mDiff < 0 && sDiff < 0) {
		//
		// 	} else {
		//
		// 	}
		//
		// 	setTimeout(function() {
		// 		setInterval(func, 1000 * 60 * 60 * 24);
		// 	}, timeToExecute);
		// }
	}

	/**
	 * Register sign that you want to run application. Application is gonna be run when ready.
	 * @param {Number} port
	 * @param {Function} callback
	 */
	runWhenReady(port, callback) {
		this.port = port;

		var interval = setInterval(() => {
			if (this.serverIsReady === true) {
				clearInterval(interval);

				if (!this.beforeRunWhenReadyCallback()) {
					this.exit();
					return;
				}

				if ($cluster.isMaster) {
					console.timeEnd("Application Master load-time: ");

					if (!debugMode) {
						callback();
						return;
					}
				}

				// Listen on given port
				this.server.listen(this.port, () => {

					this.serverIsRunning = true;

					// Print by framework registered load-time timer
					if (!debugMode) {
						console.timeEnd("Application Worker " + $cluster.worker.id + " load-time: ");

						//Invoke worker ready
						$clusterCmds.invoke($clusterCmds.Commands.WorkerReady);
					} else {
						// Logged when in debugMode; from Master
						Log.line("Server is running on port " + this.port, Log.LogTypes.Start, 0);
					}

					callback();
				});
			}
		}, 50);
	}

	/**
	 * Exit application
	 */
	exit() {
		if ($cluster.isMaster) {
			Log.line("Exiting application...", Log.LogTypes.Std, 0);
		} else {
			Log.line("Exiting child process...", Log.LogTypes.Std, 0);
			$clusterCmds.invoke($clusterCmds.Commands.ExitApp);
		}
		process.exit(0);
	}

	//</editor-fold>

	//<editor-fold desc="Private Methods">

	//<editor-fold desc="Booting Methods">

	/**
	 * This methods is called before whenReadyCallback
	 * This method check some settings before run
	 * @returns {boolean}
	 */
	beforeRunWhenReadyCallback() {
		// Check template adapter
		if (!this.templateAdapter) {
			this.setTemplateAdapter(Jumbo.Adapters.TemplateAdapter);
		}

		// Create RegExp for checking default action URL
		defaultActionRegExp = new RegExp("^/\w+" + Jumbo.Application.Locator.instance.delimiter + Application.defaultAction + "$");

		return true;
	}

	/**
	 * Initiate application clustering
	 * @private
	 */
	initClustering() {
		if ($cluster.isMaster) {
			// Fork this process - start clustering
			if (Jumbo.Config.clustering && typeof Jumbo.Config.clustering.numberOfWorkers == "number"
				&& !debugMode) {

				var cpuCount = Jumbo.Config.clustering.numberOfWorkers == 0
					? require('os').cpus().length
					: Jumbo.Config.clustering.numberOfWorkers;

				for (var c = 0; c < cpuCount; c++) {
					$cluster.fork()/*.on("error", (error) => {
					 Log.error("!!!! ERROR");
					 })*/;
				}

				var numberOfWorkerReady = 0;

				$cluster.on("exit", (worker, code, signal) => {
					Log.line(`Worker ${worker.id} exited with code: ${code | signal}`);

					// wanted exit
					if (code == 0) return;

					// Refork process after 1 sec
					setTimeout(() => {
						Log.line(`Reforking worker ${worker.id}`);
						$cluster.fork();
					}, 1000);
				}).on("message", /** @param {Worker} worker */(worker, message) => {
					Log.line("[Worker " + worker.id + "] sent message: " + JSON.stringify(message),
						Log.LogTypes.Std, Log.LogLevels.TalkativeCluster);

					switch (message.invokeAction) {
						// Logging
						case $clusterCmds.Commands.Log:
							Log.line(message.invokeData.message, message.invokeData.type, message.invokeData.level);
							break;
						// WorkerReady
						case $clusterCmds.Commands.WorkerReady:
							numberOfWorkerReady++;
							if (numberOfWorkerReady == cpuCount) {
								Log.line("Server is running on port " + this.port, Log.LogTypes.Start, 0);
							}
							break;
						case $clusterCmds.Commands.ExitApp:
							this.exit();
							break;
						case $clusterCmds.Commands.RestartWorker:
							$cluster.fork().on("online", () => {
								setTimeout(() => {
									worker.send({exit: 0});
								}, 1000);
							});
							break;
						default:
							Log.warning("Not implemented cluster message (code " + message.invokeAction + ").");
							break;
					}
				});
			}
		} else {
			process.on("uncaughtException", function (err) {
				Log.error(err.message + "\n" + err.stack);
				process.exit(1)
			}).on("message", (message) => {
				if (message.hasOwnProperty("exit")) {
					process.exit(message.exit);
				}
			});
		}
	}

	/**
	 * Compile specific LESS file
	 * @private
	 * @param {String} file Less file path
	 * @param {Jumbo.Sync.Waiter} waiter
	 */
	compileLessFile(file, waiter) {
		return $fs.readFile(file, "utf-8", (err, data) => {
			if (err) {
				//noinspection JSAccessibilityCheck
				Log.warning("Error ocurs while reading file '" + file
					+ "' while less compiling.", Log.LogTypes.Start, Log.LogLevels.Warning);
				return waiter.kick();
			}

			// Compile less to css with compression
			$less.render(data, {compress: true}, (err, compiled) => {
				if (err) {
					//noinspection JSAccessibilityCheck
					Log.warning("Error ocurs while compiling less style '" + file
						+ "' in styles compiling processBlock.", Log.LogTypes.Start, Log.LogLevels.Warning);
					return waiter.kick();
				}

				// create name for CSS file
				file = file.substr(0, file.length - 5) + ".css";

				// Write to CSS file
				$fs.writeFile(file, compiled.css, (err) => {
					if (err) {
						//noinspection JSAccessibilityCheck
						Log.warning("Error ocurs while writing compiled file '" + file
							+ "' in styles compiling processBlock.", Log.LogTypes.Start, Log.LogLevels.Warning);
						return waiter.kick();
					}

					//noinspection JSAccessibilityCheck
					Log.line("Less style was compiled into '" + file + "'", Log.LogTypes.Start, Log.LogLevels.Normal);
					waiter.kick();
				});
			});
		});
	}

	/**
	 * Method go through CSS directory and compile all .less files to .css
	 * @private
	 */
	compileLESS(callback) {
		var cssPath = $path.join(Jumbo.PUBLIC_DIR, "styles");

		$fs.readdir(cssPath, (err, files) => {
			if (err) {
				Log.error(err.message);
				return;
			}

			var waiter = new Jumbo.Sync.Waiter(files.length, () => {
				// Watch STYLES directory
				var nextChangeAfter = null;

				$fs.watch(cssPath, (event, fileName) => {
					if (fileName.slice(-5) != ".less") {
						return;
					}

					// Windows emit rename for change so all event types must be accepted
					// if (event != "change") return;

					// Cuz some systems emit more messages for one event
					setTimeout(() => {
						if (nextChangeAfter != null && (new Date()).getTime() < nextChangeAfter) return;
						nextChangeAfter = new Date().getTime() + 1000;

						this.compileLessFile($path.join(cssPath, fileName), {
							kick: function () {
							}
						}); // FiktivnÃ­ waiter
					}, 100);
				});

				callback();
			});

			files.forEach((file) => {
				if (file.substr(-5) != ".less") {
					return waiter.kick();
				}

				this.compileLessFile($path.join(cssPath, file), waiter);
			});
		});
	}

	/**
	 * Create http server
	 * @private
	 */
	createServer() {
		if (Jumbo.Config.maxRequestPerSecond !== 0) {
			// Initiate request count limits
			this.requests.limit = Jumbo.Config.maxRequestPerSecond || this.requests.limit;
			this.requests.checkInterval = setInterval(() => {
				this.requests.totalCount = 0;
				this.requests.countPerIP = {};
			}, checkIntervalTime * 1000);
		}

		// Initiate DDOS limits
		if (Jumbo.Config.DOSPrevention && Jumbo.Config.DOSPrevention.enabled === true) {
			this.requests.limitIP = Jumbo.Config.DOSPrevention.maxRequestPerIP || this.requests.limitIP;
			this.requests.banTime = Jumbo.Config.DOSPrevention.blockTime || this.requests.banTime;
		} else if (Jumbo.Config.DOSPrevention && Jumbo.Config.DOSPrevention.enabled === false) {
			this.requests.limitIP = 0;
		}

		if ($https) {
			var options = {};

			if (Jumbo.Config.protocol.privateKey && Jumbo.Config.protocol.certificate) {
				try {
					options.key = $fs.readFileSync($path.resolve(Jumbo.BASE_DIR, Jumbo.Config.protocol.privateKey));
					options.cert = $fs.readFileSync($path.resolve(Jumbo.BASE_DIR, Jumbo.Config.protocol.certificate));
				} catch (ex) {
					Log.error("Error ocurs while reading private key or certificate. " + ex.message);
					this.exit();
					return;
				}
			} else if (Jumbo.Config.protocol.pfx) {
				try {
					options.pfx = $fs.readFileSync($path.resolve(Jumbo.BASE_DIR, Jumbo.Config.protocol.pfx));
				} catch (ex) {
					Log.error("Error ocurs while reading pkcs archive. " + ex.message);
					this.exit();
					return;
				}
			} else {
				Log.error("You have not configured HTTPS server properly, key or certificate missing.");
				this.exit();
				return;
			}

			if (Jumbo.Config.protocol.passphrase) {
				options.passphrase = Jumbo.Config.protocol.passphrase;
			}

			this.server = $https.createServer(options, (req, res) => this.serverCallback(req, res));
		} else {
			this.server = $http.createServer((req, res) => this.serverCallback(req, res));
		}

		this.server.on("error", (err) => {
			if (err !== null) {
				Log.error("Server couldn't be started. Maybe port is blocked.\n" + err.message, Log.LogTypes.Std);
				this.exit();
			}
		});
	}

	//</editor-fold>

	//<editor-fold desc="Request Process Methods">

	/**
	 * Server callback for http or https server
	 * Method accepting request from HTTP server (or called from Tests)
	 * @private
	 * @param {http.IncomingMessage} request
	 * @param {http.OutgoingMessage} response
	 */
	serverCallback(request, response) {
		// X-Poweder-By
		response.setHeader("X-Powered-By", "Jumbo");

		// request start time
		var requestBeginTime = new Date().getTime();

		// Check / process maximal request count
		if (this.requests.limit != 0) {
			if (++this.requests.totalCount > this.requests.limit * checkIntervalTime) {
				this.plainResponse(response, "We're sorry but server reject your request because of overload.", 503);

				// Log in first case of overload
				if (this.requests.totalCount == this.requests.limit + 1) {
					Log.warning("Limit of request per second was reached. Last request come from: "
						+ this.getClientIP(request), Log.LogTypes.Http, Log.LogLevels.Talkative);
				}
				return;
			}
		}

		var clientIP = this.getClientIP(request);

		// Check / process maximal request count per IP
		if (this.requests.limitIP != 0) {
			// If IP in ban list
			if (this.requests.blockedIPs[clientIP]) {
				if (this.requests.blockedIPs[clientIP] <= new Date().getTime()) { // Ban ends
					delete this.requests.blockedIPs[clientIP];
				} else {
					this.plainResponse(response, "We're sorry but server reject your request.", 503);
					return;
				}
			}

			if (!this.requests.countPerIP[clientIP]) {
				this.requests.countPerIP[clientIP] = 1;
			} else {
				// Log in first case of overload
				if (++this.requests.countPerIP[clientIP] > this.requests.limitIP * checkIntervalTime) {
					this.requests.blockedIPs[clientIP] = new Date().getTime() + this.requests.banTime * 1000;
					Log.warning("Client from ip " + clientIP + " reached the ip/requests/sec limit and was blocked.", Log.LogTypes.Http);

					// Send blocked IP to listener if registered
					if (this.blockIpListener != null) {
						this.blockIpListener(clientIP);
					}
				}
			}
		}

		// Check if url ends with delimiter - redirect to url without delimiter
		var urlWithoutEndingDelim;
		if (urlWithoutEndingDelim = request.url.match(new RegExp("^(.+)" + this.locator.delimiter + "+$"))) {
			Log.line("Url ends with delimiter(s), redirecting to url without it.", Log.LogTypes.Http, Log.LogLevels.Talkative);
			this.redirectResponse(response, urlWithoutEndingDelim[1]);
			return;
		}

		// Check if request is requesting static file
		if (request.method == "GET" && request.url.slice(0, 7) == "/public") {
			var url = decodeURI(request.url);

			this.staticFileResolver($path.join(Jumbo.BASE_DIR, url), (error, fileStream, mime, size) => {
				if (error) {
					this.displayError(request, response, {
						status: 404,
						message: "File '" + url + "' error. " + error.message
					});
					return;
				}

				Log.line("Streaming static file '" + url + "'.", Log.LogTypes.Http, Log.LogLevels.Talkative);

				response.writeHead(200, {"Content-Type": mime, "Content-Length": size});
				fileStream.pipe(response);
			});
			return;
		}

		// Rest of action continue in differ method
		this.processRequest(request, response, requestBeginTime);
	}

	/**
	 * Process incoming request
	 * @private
	 * @param request
	 * @param response
	 * @param requestBeginTime
	 * @returns {*}
	 */
	processRequest(request, response, requestBeginTime) {
		//noinspection JSAccessibilityCheck
		Jumbo.Application.Request.buildRequest(request, response, this.locator, requestBeginTime, (err, req) => {
			if (debugMode) {
				console.log("[DEBUG] Application.processRequest request builded by Application.processRequest()", err);
			}

			if (err) {
				if (err instanceof Jumbo.Exceptions.UrlIsNotValidException) {
					// Check if url ends with slash
					if (request.url != "/" && request.url.slice(-1) == "/") {
						Log.line("Requested url is not valid - ends with slash => redirect",
							Log.LogTypes.Http, Log.LogLevels.Talkative);
						this.redirectResponse(response, request.url.slice(0, request.url.length - 1));
						return;
					}

					this.displayError(request, response, {
						status: 404,
						message: "Requested url '" + request.headers.host + request.url + "' is not valid. Does not match any Locator's location"
					});
					return;
				} else if (err instanceof Jumbo.Exceptions.ControllerOrActionDoesntExistsException) {
					this.displayError(request, response, {
						status: 404,
						message: "Requested url '" + request.headers.host + request.url + "' is not valid. " + err.message
					});
					return;
				}

				this.displayError(request, response, {
					status: 500,
					message: "Unknown error ocurs in Application.processRequest's callback"
				});
				return;
			}

			this.checkURL(req, () => {
				if (debugMode) {
					console.log("[DEBUG] Application.processRequest url checked by Application.checkURL()");
				}

				this.processPotentialPostAndContinue(req, (error, fields, files) => {
					if (debugMode) {
						console.log("[DEBUG] Request target suapp:", req.subApp, "controller:", req.controller, "action:", req.action);
					}

					// If POST comes
					if (fields || files) {
						req.body = {
							fields: fields,
							files: files
						};
					}

					// Create DI Scope for controller
					var scope = new Jumbo.Ioc.Scope();

					var cntrll;

					if (req.subApp !== null) {
						cntrll = this.controllerFactory.createSubAppController(req.subApp, req.controller, scope);
					} else {
						cntrll = this.controllerFactory.createController(req.controller, scope);
					}

					if (cntrll === null) {
						this.displayError(request, response, {
							status: 404,
							message: "File not found"
						});
						return;
					}

					// Get user session ID from cookies
					var userSessId = req.getCookie(Jumbo.Config.session.sessionsCookieName);

					// Load sessions from memory
					var session = this.sessions[userSessId];

					// if session in not in this.sessions, try to load session from file
					if (session == undefined) {
						// If session is justInMemory, ignore saved session
						if (Jumbo.Config.session.justInMemory === true) {
							this.initController(req, cntrll, {}, scope);
						} else {
							$fs.readFile($path.join(Jumbo.SESSION_DIR, userSessId + ".session"), "utf-8", (err, sessJson) => {
								var storedSession = {};

								// Sessin not exists
								if (!err) {
									try {
										storedSession = JSON.parse(sessJson);
									} catch (e) {
									}
								}

								this.initController(req, cntrll, storedSession, scope);
							});
						}
					} else {
						this.initController(req, cntrll, session, scope);
					}
				});
			});
		});
	}

	/**
	 * Check if URL is in long format (contain default controller or action) or not,
	 * if so, redirect to short-format URL, if not, call callback
	 * @private
	 * @param {Jumbo.Application.Request} req
	 * @param {Function} callback
	 */
	checkURL(req, callback) {
		var url = req.request.url.toLowerCase();

		if (url == "/") {
			callback();
			return;
		}

		var defAction = Jumbo.Application.Application.defaultAction.toLowerCase();
		var cntrlUrl = "/" + Jumbo.Application.Application.defaultController.toLowerCase();
		var delimiter = this.locator.delimiter;

		// Index page
		if (url == cntrlUrl || url == cntrlUrl + delimiter || url == cntrlUrl + delimiter + defAction
		) {
			Log.line("Request for main page in long format -> redirect", Log.LogTypes.Http, Log.LogLevels.Talkative);
			req.redirectURL("/");
			return;
		}

		// Default action
		if (defaultActionRegExp.test(url)) {
			req.redirect(req.controller, defAction);
			return;
		}

		callback();
	}

	/**
	 * Process POST request, get data and files
	 * @private
	 * @param {Jumbo.Applicaton.Request} req
	 * @param {Function} callback
	 */
	processPotentialPostAndContinue(req, callback) {
		if (req.request.method != "POST") {
			callback(null, null, null);
			return;
		}

		var end = false;

		var form = new $formidable.IncomingForm();
		form.uploadDir = Jumbo.UPLOAD_DIR;
		form.keepExtensions = true;

		form.on("progress", () => {
			if (form.bytesExpected > (Jumbo.Config.maxPostDataSize || 5e6)) {
				end = true;
				form.emit("error", "Post data received is too big");
				this.displayError(req.request, req.response, {
					status: 413,
					message: "Post data received is too big"
				});
				req.request.connection.destroy();
			}
		});

		form.parse(req.request, (err, fields, files) => {
			if (end) {
				return;
			}

			if (err) {
				callback(err, null, null);
				return;
			}

			callback(null, fields, files);
		});
	}

	/**
	 * Initialize controller and init action call
	 * @param {Jumbo.Application.Request} req
	 * @param {Jumbo.Base.Controller} cntrll
	 * @param {Object} session
	 * @param {Jumbo.Ioc.Scope} scope
	 */
	initController(req, cntrll, session, scope) {
		// Init controller
		cntrll.initController(req, session, (err, info) => {
			this.controllerCallback(err, info, cntrll);
		}, scope);

		if (req.body != null) {

			// TODO: Process POST, reconstruct model and validate it

			this.callAction(req, cntrll);
		} else {
			this.callAction(req, cntrll);
		}
	}

	/**
	 * Call controller's action
	 * @param req
	 * @param cntrll
	 */
	callAction(req, cntrll) {
		if (debugMode) {
			console.log("[DEBUG] Application.callAction() called");
		}

		var actionName;

		if (req.subApp) {
			actionName = this.controllerFactory.getSubAppActionName(req.subApp, req.controller, req.action);
		} else {
			actionName = this.controllerFactory.getActionName(req.controller, req.action);
		}

		var cntrlParent = Object.getPrototypeOf(cntrll.constructor);

		if (cntrlParent.prototype['beforeActions']) {
			cntrlParent.prototype['beforeActions'].call(cntrll, () => {
				if (!cntrll.exited) {
					if (cntrll.beforeActions) {
						cntrll.beforeActions(() => {
							if (!cntrll.exited) {
								this.callControllerAction(cntrll, actionName, req);
							}
						});
					} else {
						this.callControllerAction(cntrll, actionName, req);
					}
				}
			});
		} else if (cntrll.beforeActions) {
			cntrll.beforeActions(() => {
				if (!cntrll.exited) {
					this.callControllerAction(cntrll, actionName, req);
				}
			});
		} else {
			this.callControllerAction(cntrll, actionName, req);
		}
	}

	/**
	 * Call action request, build parameters to by method requested order
	 * @private
	 * @param controller
	 * @param actionName
	 * @param {Jumbo.Application.Request} request
	 */
	async callControllerAction(controller, actionName, request) {
		if (debugMode) {
			console.log("[DEBUG] Application.callControllerAction() called");
		}

		if (controller[actionName]) {
			var args = [];
			var actionArgs = [];
			var controllerIdentifier = this.controllerFactory.getControllerName(request.controller).toLowerCase();
			var actionIdetifier = actionName.toLowerCase();

			if (request.subApp == null) {
				actionArgs = this.controllerFactory.controllers[controllerIdentifier].actions[actionIdetifier].args;
			} else {
				actionArgs = this.controllerFactory.subApp[request.subApp.toLowerCase()]
					.controllers[controllerIdentifier].actions[actionIdetifier].args;
			}

			for (var i = 0; i < actionArgs.length; i++) {
				args.push(request.params[actionArgs[i]] || null);
			}

			try {
				let rtrnVal = controller[actionName].apply(controller, args);

				// Maybe it'll be better check catch existance - somebody should return non native Promise
				if (rtrnVal /* && !!rtrnVal.catch */ && rtrnVal instanceof Promise) {
					rtrnVal.catch((error) => {
						this.displayError(request.request, request.response, {status: 500, error: error});
					});
				}
			} catch (error) {
				this.displayError(request.request, request.response, {status: 500, error: error});
			}
		}
	}

	/**
	 * Controller's callback
	 * @param {Error} err
	 * @param {Object} info
	 * @param {Jumbo.Base.Controller} cntrll
	 */
	controllerCallback(err, info, cntrll) {
		if (debugMode) {
			console.log("[DEBUG] Application.processRequest controllerCallback() called");
		}

		var req = cntrll.request;
		var request = req.request;
		var response = req.response;

		// Save session, only if some data exists in session
		if (cntrll.session && Object.keys(cntrll.session).length != 0) {
			// To memory
			this.sessions[req.sessionId] = cntrll.session;

			// To disk
			$fs.writeFile($path.join(Jumbo.SESSION_DIR, req.sessionId + ".session"),
				JSON.stringify(cntrll.session), "utf-8", () => {
				});
		}

		if (err !== null) {
			this.displayError(request, response, err);
			return;
		}

		if (!info) {
			return this.displayError(request, response, {
				status: 500,
				message: "Controller's callback called with no error but no data for rendering was specified."
			});
		}

		if (info.wasReturned) {
			return Log.line(`${request.method.toUpperCase()} ${req.noCache ? "no-cached " : ""}${request.host + request.url}`
				+ ` (${req.subApp || "default"} subapp)` + ` returned in ${new Date().getTime() - req.beginTime} ms`);
		}

		// Client messages - add to data
		Object.defineProperty(info.data, "clientMessages", {
			get: function () {
				if (Object.prototype.hasOwnProperty.call(cntrll.crossRequestData, clientMessageId)) {
					return cntrll.crossRequestData[clientMessageId];
				}

				return {};
			}
		});

		this.prepareView(info, req, cntrll);
	}

	/**
	 * Create name for template cache file
	 * @param info
	 * @param req
	 * @returns {String}
	 */
	getTemplateCacheName(info, req) {
		var tplCacheFileName = (req.subApp || "Default") + "-";

		if (info.view) {
			tplCacheFileName += info.view.replace(/[^\w\\\/]/g, "").replace(/[\/\\]/g, "-");

			if (info.isSingle) {
				tplCacheFileName += "_single-template";
			}
		} else {
			tplCacheFileName += req.controller + "-" + req.action;
		}

		tplCacheFileName += tplCacheExtension;

		return $path.join(Jumbo.CACHE_DIR, tplCacheFileName);
	}

	/**
	 * Prepare view rendering
	 * @param info
	 * @param {Jumbo.Application.Request} req
	 * @param {Jumbo.Base.Controller} cntrl
	 */
	async prepareView(info, req, cntrl) {
		if (!info.view) {
			info.view = req.controller + "/" + req.action;
		}

		var writeToCache = this.templateAdapter.preCompilation && Jumbo.Config.cache.enabled;

		// Do complete (compile and) render
		if (req.noCache || !writeToCache) {
			this.renderView(info, req, cntrl, writeToCache);
			return;
		}

		// templateAdapter contain preCompilation, no noCache header in request and cache is enabled

		var tplCacheFile = this.getTemplateCacheName(info, req);

		// Cached in memory
		if (this.memoryCacheQueue.indexOf(tplCacheFile) != -1) {
			this.templateAdapter.renderPreCompiled(this.memoryCache[tplCacheFile], info.data, (err, result) => {
				this.sendView(err, result, req, cntrl);
			});
			return;
		}

		if (debugMode) {
			console.log("[DEBUG] Reading template from cache file");
		}

		$fs.readFile(tplCacheFile, "utf-8", (err, content) => {
			if (err) {
				// No cache exists - do complete (compile and) render
				this.renderView(info, req, cntrl, true);
				return;
			}

			this.templateAdapter.renderPreCompiled(content, info.data, (err, result) => {
				this.sendView(err, result, req, cntrl);
			});
		});
	}

	/**
	 * Send view to client
	 * @param {Error} error
	 * @param {String} output
	 * @param {Jumbo.Application.Request} req
	 * @param {Jumbo.Base.Controller} cntrl
	 */
	sendView(error, output, req, cntrl) {
		var request = req.request;
		var response = req.response;

		if (error) {
			this.displayError(request, response, error);
			return;
		}

		req.header["Content-Length"] = Buffer.byteLength(output, "utf-8");
		response.writeHead(200, req.header);
		response.end(output);

		this.afterTemplateRender(cntrl);

		// Check logging here because creating this log message contain a lot of logic so it
		// can save resources if it'll not log after checking inside
		if (Jumbo.Config.log.enabled && Log.level >= Log.LogLevels.Normal) {
			Log.line(`${request.method.toUpperCase()} ${req.noCache ? "no-cached " : ""}${request.url}`
				+ ` (${req.subApp || "default"} subapp)` + ` returned in ${new Date().getTime() - req.beginTime} ms`);
		}
	}

	/**
	 * New complete (compile and) render of view
	 * @param info
	 * @param {Jumbo.Application.Request} req
	 * @param {Jumbo.Base.Controller} cntrl
	 */
	async renderView(info, req, cntrl, writeToCache = false) {
		var appPath = Jumbo.APP_DIR;

		if (req.subApp != null) {
			appPath = $path.join(Jumbo.APP_DIR, "sub-apps", this.controllerFactory.subApp[req.subApp].dir);
		}

		var templatePath = $path.join(appPath, "templates", info.view + this.templateAdapter.extension);
		var layoutPath = null;

		if (info.isSingle) {
			if (debugMode) {
				console.log("[DEBUG] Render single template", templatePath);
			}
		} else {
			layoutPath = $path.join(appPath, "templates", "layout" + this.templateAdapter.extension);

			if (debugMode) {
				console.log("[DEBUG] Render template", templatePath, "with layout", layoutPath);
			}
		}

		try {
			var output;

			// templateAdapter has preCompilation and cache is enabled => preCompile template and save it to cache
			if (writeToCache) {
				if (debugMode) {
					console.log("[DEBUG] Precompiling template");
				}

				this.templateAdapter.preCompile(templatePath, layoutPath, (err, compiledtemplate) => {
					if (err) {
						this.displayError(req.request, req.response, err);
						return;
					}

					var tplCacheFile = this.getTemplateCacheName(info, req);

					// Buffer.byteLength() should be used but .length on string is faster
					// and diff in size shouldn't be big. Maybe if template will be full of >= 2B unicode characters
					// then should be difference big (2x bigger or a little bit more)
					//
					// Buffer.byteLength() is 30 times slower

					// Maybe logic of storing templates should be changed. Now last requested template is added to memory,
					// but it should be better to track number of request for which template and keep the most
					// requested templates

					// If stored -> remove
					if (this.memoryCache[tplCacheFile]) {
						this.memoryCacheSize -= this.memoryCache[tplCacheFile].length; // <- Buffer.byteLength
						delete this.memoryCache[tplCacheFile];
					}

					let size = compiledtemplate.length; // <- Buffer.byteLength

					// If file can be saved to memory cache (fit limit)
					if (size < Jumbo.Config.cache.memoryCacheSizeLimit) {
						// clear old templates from memory cache and allow new template to save
						while (this.memoryCacheSize + size > Jumbo.Config.cache.memoryCacheSizeLimit) {
							let item = this.memoryCacheQueue.shift();
							this.memoryCacheSize -= this.memoryCache[item].length; // <- Buffer.byteLength
							delete this.memoryCache[item];
						}

						this.memoryCache[tplCacheFile] = compiledtemplate;
						this.memoryCacheSize += size;
						this.memoryCacheQueue.push(tplCacheFile);
					}

					$fs.writeFile(tplCacheFile, compiledtemplate, () => {
					});

					this.templateAdapter.renderPreCompiled(compiledtemplate, info.data, (err, result) => {
						this.sendView(err, result, req, cntrl);
					});
				});
			} else {
				if (debugMode) {
					console.log("[DEBUG] Complete (compile and) render");
				}

				// Do complete (compile and) render
				this.templateAdapter.render(templatePath, layoutPath, info.data, (err, result) => {
					this.sendView(err, result, req, cntrl);
				});
			}
		} catch (error) {
			this.displayError(req.request, req.response, error);
		}
	}

	/**
	 * Called after template render
	 * @param cntrl
	 */
	afterTemplateRender(cntrl) {
		// Delete cross request data from controller
		cntrl.clearOldCrossRequestData();
	}

	//</editor-fold>

	//<editor-fold desc="Helping Methods">

	//noinspection JSMethodCanBeStatic
	/**
	 * Returns IP address from given reques
	 * @private
	 * @param request
	 * @returns {String}
	 */
	getClientIP(request) {
		return request.headers['X-Forwarded-For'] || request.connection.remoteAddress;
	}

	/**
	 * End request as plain/text with content length header
	 * @param message
	 * @param code
	 */
	plainResponse(response, message, code) {
		response.writeHead(code, {"Content-Type": "text/plain", "Content-Length": Buffer.byteLength(message, "utf-8")});
		response.end(message);
	}

	/**
	 * Redirect to given URL
	 * @private
	 * @param response
	 * @param {String} url
	 */
	redirectResponse(response, url) {
		response.writeHead(302, {"Location": url});
		response.end();
	}

	/**
	 * Return error page to client; try to find <errCode>.html in data/errors
	 * @private
	 * @param request
	 * @param response
	 * @param {{status: Number, message: String, error: Error} | Error} err
	 */
	displayError(request, response, err) {
		// err.error - for showing errors in browser in the future
		if (!err.message && err.error) {
			err.message = err.error.message;

			if (!err.status) {
				err.status = 500;
			}
		} else if (err instanceof Error) {
			err = {
				message: err.stack,
				status: 500
			}
		}

		var errFile = $path.resolve(Jumbo.ERR_DIR, err.status + ".html");

		if ($fs.existsSync(errFile)) {
			if (err.message != null)
				Log.warning("Error while serving " + request.url + "; Client " + this.getClientIP(request) + "; "
					+ err.message, Log.LogTypes.Http);

			this.staticFileResolver(errFile, (error, fileStream, mime, size) => {
				if (error) {
					Log.error("Applicaton.displayError(): " + error.message);
					this.displayError(request, response, {status: 404, message: "File '" + errFile + "' not found."});
					return;
				}

				response.writeHead(err.status, {"Content-Type": "text/html", "Content-Length": size});
				fileStream.pipe(response);
			});
		} else {
			try {
				this.plainResponse(response, err.status, "Status code " + err.status + "\nWe're sorry but some error occurs.");
			} catch (ex) {
				Log.error(ex.message, Log.LogTypes.Std);
			}

			if (err.message != null)
				Log.warning("Error while serving " + request.url + "; Error file doesn't exists; " + err.message,
					Log.LogTypes.Http);
		}
	}

	//</editor-fold>

	//</editor-fold
}

module.exports = Application;