/**
 * This file is part of Jumbo framework for Node.js
 * Written by Roman Jámbor ©
 */


var Log = Jumbo.Logging.Log;


const $qs = require("querystring");
const $url = require("url");
const $object = require("../utils/object.js");

const defaultLanguage = Jumbo.Config.globalization.defaultLanguage;
const globalizationEnabled = Jumbo.Config.globalization.enabled;

var instance = null;

/**
 * Class Locator for work with URLs and routing
 * @class Locator
 * @memberOf Jumbo.Application
 */
class Locator {

	//<editor-fold desc="Static Properties">

	/**
	 *
	 * @returns {{Integer: RegExp, StringId: RegExp, Number: RegExp}}
	 * @constructor
	 */
	static get ParamTypes() {
		return {
			Integer: /[0-9]+/,
			StringId: /[a-zA-Z_]/,
			Number: /[0-9]*(?:\.[0-9]+)?/
		};
	}

	/**
	 * Default controller name
	 * @type {string}
	 */
	static get defaultController() {
		return "Home";
	}

	/**
	 * Default action name
	 * @type {string}
	 */
	static get defaultAction() {
		return "index"
	}

	/**
	 * Get Locator instance
	 * @returns {Jumbo.Application.Locator}
	 */
	static get instance() {
		if (instance == null) {
			instance = Reflect.construct(Locator, [], LocatorActivator);
		}

		return instance;
	}

	//</editor-fold>

	//<editor-fold desc="Ctor">

	/**
	 * @constructs
	 */
	constructor() {
		if (new.target != LocatorActivator) {
			throw new Error("You cannot call private constructor!");
		}

		/**
		 * Array of supported addresses
		 * @type {Array}
		 * @private
		 */
		this.locations = {}; // [] // TODO: přeimplementovat na mapu => je třba udržet pořadí lokací

		/**
		 * Default main subdomain
		 * @type {String}
		 * @private
		 */
		this.main = "www";

		/**
		 * Registered subdomains
		 * @type {Array}
		 * @private
		 */
		this.subDomains = [];

		/**
		 * Server hostname
		 * @type {String|null}
		 * @private
		 */
		this.host = null;

		/**
		 * Delimiter for URL parts spliting controller, action etc.
		 * @private
		 * @type {string}
		 */
		this.delimiter = "/";

		/**
		 * List of static URLs and their aliases
		 * @private
		 * @type {Array}
		 */
		this.urlAliases = {};
	}

	//</editor-fold>

	//<editor-fold desc="Public Methods">

	/**
	 * Set server hostname - used for subapp link creation
	 * @param {String} host
	 */
	setHost(host) {
		this.host = host;
	}

	/**
	 * Set URL part delimiter spliting controller, action etc.
	 * Eg. delimiter ~ => domain.tld/controller~action~id
	 * @param delimiter
	 */
	setDelimiter(delimiter) {
		this.delimiter = delimiter;
	}

	/**
	 * Set default subdomain which will route to base app; both urls with and without main subdomain will work
	 * It's good for cases when you host application on some subdomain eg. myapp.domain.tld. Main subdomain is set to "www"
	 * @param {String} subName
	 */
	setMainSubdomain(subName) {
		this.main = subName.toLowerCase();
	}

	/**
	 * Register sub-app to Locator as subdomain
	 * @param {String} subName Název subdomény
	 */
	addSubdomain(subName) {
		this.subDomains.push(subName.toLowerCase());
	}

	/**
	 * Add new location to Locator
	 * @param {String} locationName
	 * @param {String} location
	 * @param {Object|null} [options]
	 * @param {String} subApp
	 */
	addLocation(locationName, location, options = null, subApp = null) {
		if (typeof location != "string") {
			throw new Error("Locaton must be string.");
		}

		if (options !== null && options.constructor != Object) {
			throw new Error("Options parameter must be Object.");
		}

		if (this.locations[locationName]) {
			throw new Error("Location with this name already exists.");
		}

		options = options || {};

		// Add language if enabled
		if (globalizationEnabled) {
			location = "[$globlanguage" + "/]" + location;
		}

		var loc = {
			location: location,
			locationMatcher: null,
			controller: null,
			action: null,
			params: options.params || {},
			targetedController: false, // It's location which not specify controller nor action, both are defined in options
			targetedAction: false,
			options: options,
			subApp: subApp,
			variables: [] // Names of variables in order as defined in location
			// controllerIndex: -1,
			// actionIdex: -1 // Indexes are used for replace when creating URL;
			// // Indexes are found here while start than later in each request mb many times - little performance improvement
		};

		if (options.controller) {
			loc.controller = options.controller;
			loc.targetedController = true;
		} else {
			// If no controller is defined than location must contain $controler variable
			if (!location.match(/\$controller/)) {
				throw new Error("No controller specified in this location.");
			}
		}

		if (options.action) {
			loc.action = options.action;
			loc.targetedAction = true;
		} else {
			// If no action is defined than location must contain $action variable
			if (!location.match(/\$action/)) {
				throw new Error("No action specified in this location.");
			}
		}

		// Create regex for this location

		// Mark start
		location = "^" + location;

		// proc optional part
		location = location.replace(/\[/g, "(?:");
		location = location.replace(/]/g, ")?");

		// Replace location delmiter with registered delimiter
		if (this.delimiter != "/") {
			var delimiter = this.delimiter;

			if (["\\", ".", "*", "?", "+", "|", "(", ")", "[", "]", "{", "}"].indexOf(delimiter) != 1) {
				delimiter = "\\" + delimiter;
			}

			location = location.replace(/\//g, this.delimiter);
		}

		// proc variables
		loc.locationMatcher = location.replace(/\$([a-z][a-zA-Z]*)/g, (_, varName) => {
			loc.variables.push(varName);

			if (varName == "globlanguage") {
				return "([a-z]{2})";
			}

			if (varName == "controller") {
				return "([a-zA-Z]{3,})";
			}

			if (varName == "action") {
				return "([a-zA-Z]{2,})";
			}

			varName = "$" + varName;

			if (options[varName]) {
				return "(" + options[varName].toString().slice(1, -1) + ")";
			}

			return "([a-zA-Z0-9-_]+)";
		}) + "$";

		this.locations[locationName] = loc;
	}

	/**
	 * Generate full URL with protocol and host. Host must be set by setHost().
	 * @param {String} controller
	 * @param {String} action
	 * @param {Array} [lashParams]
	 * @param {Object} [queryParams]
	 * @param {String} [subApp]
	 * @param {String} [lang]
	 * @param {String} [protocol]
	 * @param {String} [host]
	 * @returns {string}
	 */
	generateUrl(controller, action, slashParams = null, queryParams = null, subApp = null, lang = null, protocol = null, host = null) {
		if (!Application.controllerFactory.controllerAndActionExist(controller, action, subApp)) {
			throw new Error("Controller or it's action doesn't exists.");
		}

		var baseUrl = "/";

		if (host || protocol || subApp) {
			baseUrl = (protocol || "http") + "://" + (!!subApp ? (subApp + ".") : "") + (host || this.host) + "/";
		}

		if (lang && lang != defaultLanguage && globalizationEnabled) {
			baseUrl += lang + this.delimiter;
		}

		if (!slashParams) {
			slashParams = [];
		}

		if (!queryParams) {
			queryParams = {};
		}

		var queryParamsLength = Object.keys(queryParams).length;
		var noParams = slashParams.length == 0 && queryParamsLength == 0;

		// Base controller and action - return base URL
		if (controller == defaultController
			&& action == defaultAction && noParams
		) {
			return baseUrl;
		}

		// Default action - return base URL just with controller
		else if (action == defaultAction && noParams
		) {
			return baseUrl + controller.toLowerCase();
		}
		else {
			var url = baseUrl + controller.toLowerCase() + this.delimiter + action.toLowerCase();

			if (!noParams) {
				if (slashParams.length == 0) url += this.delimiter;

				for (var i = 0; i < slashParams.length; i++) {
					url += this.delimiter + slashParams[i];
				}

				if (queryParamsLength != 0) {
					var x = false;

					for (var p in queryParams) {
						if (queryParams.hasOwnProperty(p)) {
							if (x) {
								url += "&";
							} else {
								url += "?";
								x = true;
							}

							url += p + "=" + encodeURIComponent(queryParams[p]);
						}
					}
				}
			}

			return url;
		}
	}

	/**
	 * Create URL from specified Location
	 * @param {String} locationName
	 * @param {String} [controller]
	 * @param {String} [action]
	 * @param {Object} [params]
	 * @param {String} [lang]
	 * @returns {String}
	 */
	generateLocationUrl(locationName, controller = null, action = null, params = {}, lang = null) {
		if (!this.locations[locationName]) {
			throw new Error("Location with this name doesn't exists.");
		}

		if (params.constructor != Object) {
			throw new Error("Parameter params must be Object");
		}

		var location = this.locations[locationName];

		if (location.options.controller) {
			controller = location.options.controller;
		}

		if (location.options.action) {
			action = location.options.action;
		}

		// Remove optional parameters -> remove brackets
		var loc = location.location.replace(/\[|\]/g, "");

		return "/" + loc.replace(/(\/)?\$([a-z][a-zA-Z]*)/g, (_, delimiter, varName) => {
			if (varName == "globlanguage") {
				if (!lang) {
					return this.delimiter + Jumbo.Config.globalization.defaultLanguage;
				}
				return this.delimiter + action.toLowerCase();
			}

			if (varName == "controller") {
				if (!controller) {
					throw new Error("This location require controller but you don't pass any in parameters.");
				}

				return controller.toLowerCase();
			}

			if (varName == "action") {
				if (!action) {
					throw new Error("This location require action but you don't pass any in parameters.");
				}
				return this.delimiter + action.toLowerCase();
			}

			if (params[varName]) {
				return this.delimiter + params[varName];
			}

			if (location.options[varName]) {
				return this.delimiter + location.options[varName];
			}

			return "";
		});
	}

	//noinspection JSMethodCanBeStatic
	/**
	 * Extract subapp from request
	 * @param {http.IncomingMessage} request
	 * @returns {Array}
	 */
	extractSubApp(request) {
		var host = request.headers.host.replace(/:[0-9]+$/, ""); //request.url.replace(/http(s)?:\/\//, "");

		// Test if host is IP - no subapp
		if ((/[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}/).test(host)) {
			return null;
		}

		// Count domains - if less than 3, no subdomain used
		var s = host.split(".");
		if (s.length < 3) {
			return null;
		}

		return s[0];
	}

	/**
	 * Parse URL address to parts (controller, acton, subapp)
	 * @param {http.IncomingMessage} request
	 * @returns {Object | null}
	 */
	parseUrl(request) {
		//noinspection JSUnresolvedVariable
		var url = request.url;

		// Find subapp
		var subApp = this.extractSubApp(request);

		if (subApp !== null) {
			subApp = subApp.toLowerCase();
		}

		if (subApp == this.main) {
			subApp = null;
		}

		if (subApp !== null) {
			var found = false;
			var d = 0;
			var dl = this.subDomains.length;

			while (!found && d < dl) {
				if (this.subDomains[d] == subApp) found = true;
				d++;
			}

			if (!found) {
				return null;
			}
		}

		// Parse URL to parts
		var parse = $url.parse(url);

		var emptyPath = parse.pathname == "/";

		// If just slash
		if (emptyPath || parse.pathname.length == 3) { // / or eg. /en - controller must have at least 3 characters
			// should be validate with regex but it's gonna be taken as language so jung language will have bad format
			// user catch that and show error, that given language doesn't exists
			var lang = parse.pathname.slice(1) || defaultLanguage;
			return {
				location: null,
				subApp: subApp,
				controller: defaultController,
				action: defaultAction,
				params: $qs.parse(parse.query),
				language: lang,
				shouldCheck: !emptyPath,
				hasParams: false,
				actionInUrl: false
			};
		}

		// Path
		url = parse.pathname.slice(1); // Slice remove first slash

		var matched = false;
		var match;
		var locNames = Object.keys(this.locations);
		var c = locNames.length;
		var locIndex;
		var location;

		// Procedure which try if some registered location match
		const tryToMatchProc = (url) => {

			// Try to match
			for (var i = 0; !matched && i < c; i++) {
				location = this.locations[locNames[i]];

				match = url.match(location.locationMatcher);

				if (match !== null && (
						// If no subapp in request and matched location is for main subapp
						(subApp === null && location.subApp == this.main)

						// OR subapp in request match subapp in location
						|| subApp == location.subApp

						// OR no subapp in matched location speficied (location for all subapps)
						|| location.subApp === null
					)
				) {
					locIndex = locNames[i];
					matched = true;
				}
			}
		};

		var shouldCheck = true;

		// Try to match current url path
		tryToMatchProc(url);

		// If not matched before, try to match with added action
		if (!matched && (/^\/[a-z]+$/).test(url)) {// If only /controller
			var tmpUrl = url + this.delimiter + defaultAction;
			tryToMatchProc(tmpUrl);
			shouldCheck = false;
		}

		if (matched) {
			var location = this.locations[locIndex];

			var matchedAction = match[location.variables.indexOf("action") + 1];

			var res = {
				location: locIndex,
				subApp: subApp,
				controller: location.targetedController
					? location.controller
					: match[location.variables.indexOf("controller") + 1],
				action: location.targetedAction
					? location.action
					: (matchedAction || defaultAction),
				params: $object.clone(location.params),
				//location: location,
				language: match[1] || defaultLanguage,
				shouldCheck: true,
				hasParams: false,
				actionInUrl: !!matchedAction
			};

			c = location.variables.length;

			// Slash params
			for (var i = 0; i < c; i++) {
				if (location.variables[i] != "controller" && location.variables[i] != "action"
					&& location.variables[i] != "globlanguage"
				) {
					res.params[location.variables[i]] = match[i + 1];
					if (!res.hasParams && match[i + 1] != undefined) {
						res.hasParams = true;
					}
				}
			}

			// Query params
			var queryParams = $qs.parse(parse.query);

			for (var qp in queryParams) {
				res.params[qp] = queryParams[qp];
			}

			if (!res.hasParams && !!Object.keys(queryParams).length) {
				res.hasParams = true;
			}

			return res;
		}

		return null;
	}

	/**
	 * Create alias for some url. Eg. you have static file /public/robots.txt and you want to be under url /robots.txt
	 * so then add url alias addUrlAlias("/public/robots.txt", "/robots.txt")
	 * @param {String} url Target URL
	 * @param {String} alias Alias for target URL
	 */
	addUrlAlias(url, alias) {
		this.urlAliases[alias] = url;
	}

	//</editor-fold>

	//<editor-fold desc="Private Methods">

	/**
	 * Return URL for alias if registered, otherwise null
	 * @private
	 * @param {String} alias
	 * @returns {String | null}
	 */
	getUrlForAlias(alias) {
		if (!this.urlAliases.hasOwnProperty(alias)) return null;
		return this.urlAliases[alias];
	}

	//</editor-fold>
}

class LocatorActivator extends Locator { }

const defaultController = Locator.defaultController;
const defaultAction = Locator.defaultAction;

module.exports = Locator;