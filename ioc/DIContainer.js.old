/**
 * This file is part of Jumbo framework for Node.js
 * Written by Roman Jámbor ©
 */

"use strict";

const $cryptUtil = require("../utils/crypt");

let instance = null;

/**
 * IoC Dependency Injection Container used for registering and resolving types
 * @description This class solve IoC. It creates DI registrar and resolver,
 * it means you can regiser your types and than resolve them manualy or let them be resolved automaticaly
 * @memberOf Jumbo.Ioc
 */
class DIContainer {

	//<editor-fold desc="Virtual Definitions">

	/**
	 * Expression for method register() in DIContainer. Expresson should return Type or instance.
	 * @callback diRegisterExpression
	 * @returns {class | Function | Object}
	 */

	/**
	 * Result type of method resolveArguments
	 * @typedef {args: [], type: class | Function | Object} resolveArgumentsResult
	 */

	//</editor-fold>

	//<editor-fold desc="Static Properties">

	/**
	 * Enum of LifetimeScopes
	 * @returns {{SingleInstance: Jumbo.Ioc.DIContainer.LifetimeScope, ScopeInstance: Jumbo.Ioc.DIContainer.LifetimeScope, InstancePerResolve: Jumbo.Ioc.DIContainer.LifetimeScope}}
	 */
	static get LifetimeScope() {
		return {
			SingleInstance: "singleinstance",
			ScopeInstance: "scopeinstance",
			InstancePerResolve: "instanceperresolve"
		};
	}

	/**
	 * Get instance of DIContainer
	 * @returns {Jumbo.Ioc.DIContainer}
	 */
	static get instance() {
		if (instance === null) {
			instance = Reflect.construct(DIContainer, [], DIContainerActivator);
		}

		return instance;
	}

	//</editor-fold>

	//<editor-fold desc="Ctor">

	/**
	 * Constructor
	 */
	constructor() {
		if (new.target != DIContainerActivator) {
			throw new Error("You cannot call private constructor!");
		}

		/**
		 * List of registered types
		 * @private
		 * @type {{}}
		 */
		this.registeredTypes = {};
	}

	//</editor-fold>

	//<editor-fold desc="Public Methods">

	/**
	 * Register type (returned by expr function) under name (as)
	 * @param {class | Function | diRegisterExpression} expr Expression (function) which should return Type or instance you want to return by resolve
	 * @param {String} as Name of Type which you register
	 * @param {Jumbo.Ioc.DIContainer.LifetimeScope} [scope]
	 */
	register(expr, as, scope = "instanceperresolve") {
		this.registeredTypes[as] = {
			expr: expr,
			isExpr: !expr.prototype && expr.toString().slice(0, 5) != "class",
			args: null, // Will be filled after first resolve,
			scope: scope,
			instance: null // Will be filled after first resolve if scope is SingleInstance
		};
	}

	/**
	 * Resolve arguments for Type with given name
	 * @param {String} name
	 * @returns {resolveArgumentsResult} Returns object with resolved arguments and looked up type
	 * @throws {Error} If no type under name exists or if registered type isn't class
	 */
	resolveArguments(name, _scope = null) {
		if (!this.registeredTypes[name]) {
			throw new Error(`No Type under name '${name}' is registered in DI Container.`);
		}

		var regType = this.registeredTypes[name];

		// If registered type is registered for application scope and its instance was already created
		if (regType.scope == DIContainer.LifetimeScope.SingleInstance && regType.instance) {
			return {
				args: null,
				type: regType.instance
			}
		}

		// If registered type is registered for ScopeInstance and its instance was already created
		if (_scope != null && regType.scope == DIContainer.LifetimeScope.ScopeInstance && _scope.instances[name]) {
			return {
				args: null,
				type: _scope.instances[name]
			}
		}

		var type;

		// Expr is ArrowFunction returning Type or instance of Type
		if (regType.isExpr) {
			type = regType.expr();
		} else {
			// Otherwise it's Type
			type = regType.expr;
		}

		// It's instance
		if (typeof type == "object") {
			return {
				args: null,
				type: type
			};
		}

		// If type's args were already resolved and its length is 0
		if (regType.args && regType.args.length == 0) {
			return {
				args: [],
				type: type
			};
		}

		// It's not class
		if (typeof type != "function") {
			throw new Error(`Bad type with name ${name} is registered in DI Container, it can't be resolved.`);
		}

		// It's class

		// Get list of constructor arguments
		if (!regType.args) {
			regType.args = Application.controllerFactory.getConstructorArgsList(type.prototype.constructor);

			// Constructor have no args
			if (regType.args.length == 0) {
				return {
					args: [],
					type: type
				};
			}
		}

		// Resolve args

		var args = [];

		// Check if constructor arguments are registered
		for (var i = 0; i < regType.args.length; i++) {
			if (this.registeredTypes[regType.args[i]]) {
				if (_scope != null) {
					args.push(_scope.resolve(regType.args[i]));
				} else {
					args.push(this.resolve(regType.args[i]));
				}
			} else {
				args.push(null);
			}
		}

		return {
			args: args,
			type: type
		};
	}

	/**
	 * Resolve instance of Type registered under given name
	 * @param {String} name
	 */
	resolve(name, _scope = null) {
		try {
			var argResult = this.resolveArguments(name, _scope);

			// If instance is registered
			if (argResult.args == null) {
				return argResult.type;
			}

			var instance;

			// Constructor have no args
			if (argResult.args.length == 0) {
				instance =  new argResult.type();
			} else {
				instance = Reflect.construct(argResult.type, argResult.args);
			}

			var regType = this.registeredTypes[name];

			if (regType.scope === DIContainer.LifetimeScope.SingleInstance && !regType.instance) {
				regType.instance = instance;
			}

			if (_scope !== null && regType.scope === DIContainer.LifetimeScope.ScopeInstance && !_scope.instances[name]) {
				_scope.instances[name] = instance;
			}

			return instance;
		} catch (e) {
			Jumbo.Logging.Log.warning(e.message);
			return null;
		}
	}

	/**
	 * Resolve unregistered type
	 * @param {class | Function | diRegisterExpression} type
	 * @returns {*}
	 */
	resolveUnregistered(type, _scope = null) {
		var name = type.__diContainerUid;

		// Generate UID and save it to secret field on type
		if (!name) {
			name = type.__diContainerUid = $cryptUtil.uid();

			// Register if not registered
			if (!this.registeredTypes[name]) {
				this.register(type, name, DIContainer.LifetimeScope.InstancePerResolve);
			}
		}

		return this.resolve(name, _scope);
	}

	//</editor-fold>
}

/**
 * Activator used for creating instance of DIContainer
 */
class DIContainerActivator extends DIContainer {
}

module.exports = DIContainer;